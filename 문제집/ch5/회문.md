5-5 회문 ThePalidrome
=================
# 문제(요구사항)
존과 브루스는 대학에서 문자열 이론을 공부하고 있습니다.</br>
브루스는 회문을 아주 좋아합니다.</br>
회문은 앞에부터 읽으나, 뒤에서부터 읽으나 같은 단어를 말합니다.</br>
존은 브루스를 임의의 문자열 s로 회문을 만들어 브루스를 깜짝 놀래켜주고 싶습니다.</br>
이때 존은 문자열 s 뒤에 0이상의 숫자를 추가해 회문을 생성하려고 합니다.</br>
존이 생성할 수 있는 가장 짧은 회문의 길이를 리턴하세요.</br>
# 소스 코드
```cpp
#include <iostream>
#include <string.h>

using namespace std;

class ThePalidrome {
public:
	int find(string s)
	{
		for (int i = s.size(); ; i++) 
		// 문자열이 끝에서부터 검사하기 위해서 i = s.size()
		{
			bool flag = true;	
			// '참'이라고 가정하고 '거짓'인 경우를 제외해가는 논리를 쓰기 위해 선언함
			for (int j = 0; j < s.size(); j++)	
			// 실질적인 회문 검사->'거짓'인 경우를 찾아냄
			{
				if ((i - j - 1) < s.size() && s[j] != s[i - j - 1])	// [(i - j - 1) < s.size()]의미 : 문자열 끝에서부터 인덱싱하기 위함, s.size()보다 크다면 실제 문자열 밖의 인덱스이다. [ s[j] != s[i-j-1] ] 부분은 false 를 체크하는 것이다.
				{
					flag = false;
					break;
				}
			}
			return i;
		}
	}
};
```
# 알고리즘 설명
주어진 문자열에 가상으로 인덱스 0부터 해당하는 문자를 삽입해서 비교하는 방식

만들어질 수 있는 문자열에 대해 모두 검사하지 않아도 되기 때문에, 실행시간이 짧고, 사용하는 메모리양도 적다.
만약 만들어질 수 있는 문자열들을 만들어서 가장 짧은 회문을 비교한다고 하면,

# 예외사항
나는 처음에 회문 검사하는 개념을 이용해서 문제에 접근했고,
입력받은 문자열에 reverse 문자열을 붙여서 회문검사를 하려고 했는데 완전 잘못된 접근이였다.
[abccc]가 입력된다면 ccc부분은 c가 추가되지 않고도 회문이 만들어 질 수 있기 때문에 문자열 전체를 reverse하면 안된다.

# 이해가 안되는 것
책에서 다른 해결 방법으로 2n-1개의 문자열들을 비교해서 최소값을 찾을 수 있다고 했는데,
[2n - 1] 값이 어떻게 나온지 모르겠다.